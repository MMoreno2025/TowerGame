//Malia && Colin | 25 February 2025//
package com.mycompany.towergame;

//import neccessary packages//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.awt.geom.Point2D;

public class TowerGame {
    //make constant variables --  speciifcally screen size//
    public static final int GameWidth = 800;
    public static final int GameHeight = 600;
    
    //start game//
    public static void main(String[] args) {
        
        SwingUtilities.invokeLater(() -> {      //draws game safly and prevents freezing//
            //make frame for the game//
            JFrame frame = new JFrame("Tower Defense");
            frame.setSize(TowerGame.GameWidth, TowerGame.GameHeight);
            frame.setLocationRelativeTo(null);
            frame.setResizable(false);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            TowerDefense gamePanel = new TowerDefense();
            frame.add(gamePanel);
            frame.setVisible(true);
        });
        System.out.println("I Work!");
    }
}


class TowerDefense extends JPanel implements ActionListener, MouseListener{
    //set start game variables//
    private int money = 100, health = 100, round = 1;       //make basic display info//
    private long lastSpawnTime = 0, spawnDelay = 2000;      //delays spawn time for ships//
    private int shipsToSpawn = 5, shipsSpawned = 0;     //tell how many ships should be on screen//
    private boolean gameOver = false;       //check if game is over//
    private Timer gameTimer;        //create game timer//

    //set game elements arrays (of classes)//
    private ArrayList<Spaceship> spaceships = new ArrayList<>();
    private ArrayList<Point> placementLocations = new ArrayList<>();
    private ArrayList<Tower> towers = new ArrayList<>();
    
    //make placement position when building//
    private Point2D.Float[] path;
    private Point currentPlacement = null;
    private Tower selectedTower = null;
    
    
    //make constructor class for tower defense//
    public TowerDefense(){
        //set display screen//
        setPreferredSize(new Dimension(TowerGame.GameWidth, TowerGame.GameHeight));
        setBackground(Color.BLACK);
        addMouseListener(this);
        
        //initialize game timer 60FPS//
        gameTimer = new Timer(16, this);
        
        //deine path points to connect//
        path = new Point2D.Float[] {
            new Point2D.Float(-50, 300),  // Start off-screen
            new Point2D.Float(50, 300),
            new Point2D.Float(200, 300),
            new Point2D.Float(300, 200),
            new Point2D.Float(600, 200),
            new Point2D.Float(400, 400),
            new Point2D.Float(600, 400),
            new Point2D.Float(700, 400),
            new Point2D.Float(850, 400)   // End off-screen
        };
        
        //define places to put tower//
        placementLocations.add(new Point(150, 240));
        placementLocations.add(new Point(230, 180));
        placementLocations.add(new Point(320, 140));
        placementLocations.add(new Point(420, 140));
        placementLocations.add(new Point(520, 140));
        placementLocations.add(new Point(620, 140));
        placementLocations.add(new Point(650, 240));
        placementLocations.add(new Point(560, 330));
        
        placementLocations.add(new Point(150, 360));
        placementLocations.add(new Point(260, 340));
        placementLocations.add(new Point(330, 265));
        placementLocations.add(new Point(440, 265));
        
        
        gameTimer.start();
    }
    
    //draw path//
    private void drawPath(Graphics2D g2d){
        //set color of path//
        g2d.setColor(new Color(50, 50, 100));
        g2d.setStroke(new BasicStroke(30, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        //actually draw path//
        for(int i=0; i<path.length-1; i++){
            g2d.drawLine((int)path[i].x, (int)path[i].y, (int)path[i+1].x, (int)path[i+1].y);
        }
        
        //make path borders//
        g2d.setColor(new Color(100, 100, 200));
        g2d.setStroke(new BasicStroke(32, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 0, new float[]{10, 10}, 0));
        //actually draw path again//
        for (int i = 0; i < path.length - 1; i++) {
            g2d.drawLine((int)path[i].x, (int)path[i].y, (int)path[i+1].x, (int)path[i+1].y);
        }
    }
    
    //draw towers//
    private void drawPlacmentLocations(Graphics2D g2d){
        g2d.setColor(new Color(0, 255, 0, 100));
        
        //check if location is bought yet//
        for(Point loc: placementLocations){
            boolean occupied = false;
            
            //check if tower already exists in location//
            for(Tower tower: towers){
                if(tower.getX() == loc.x && tower.getY() == loc.y){
                    occupied = true;
                    break;
                }
            }
            
            if(!occupied){
                g2d.fillRect(loc.x-20, loc.y-20, 40, 40);
                g2d.setColor(new Color(0, 255, 0, 200));
                g2d.drawRect(loc.x-20, loc.y-20, 40, 40);
                g2d.setColor(new Color(0, 255, 0, 100));
            }
        }
    }
    
    //Create Spaceships//
    private void startNextRound(){
        round++;
        shipsToSpawn = 5*round;
        shipsSpawned = 0;
        spawnDelay = Math.max(500, 2000-round*100);
    }
    
    private void spawnSpaceship(){
        int health = round;
        float speed = 1.0f + (round * 0.1f);
        spaceships.add(new BasicSpaceship(path, health, speed));
    }
    
    private void updateSpaceships(){
        Iterator<Spaceship> it = spaceships.iterator();
        while(it.hasNext()){
            Spaceship ship = it.next();
            ship.move();
            
            //remove ships and decrease health of player if ships reach the end//
            
            if(ship.hasReachedEnd()){
                health -= ship.getDamage();
                it.remove();
            }
        }
    }
    
    private void updateTowers(){
        for(Tower tower: towers){
            tower.update();
            
            //fire at nearby ship in range//
            if(tower.canFire()){
                Spaceship target = findNearestSpaceshipInRange(tower);
                if(target != null){
                    Projectile projectil = tower.fire(target);
                    if(project != null){
                        projectil.add(projectile);
                    }
                }
            }
        }
    }
    
    private Spaceship findNearestSpaceshipInRang(Tower tower){
        Spaceship nearest = null;
        double minDistance = Double.MAX_VALUE;
        
        for(Spaceship ship: spaceships){
            double distance = Point2D.distance(tower.getX(), tower.getY(), ship.getX(), ship.getY());
            if(distance<=tower.getRange() && distance<minDistance){
                minDistance = distance;
                nearest = ship;
            }
        }
        
        return nearest;
    }
    //place tower on click//
    @Override
    public void mouseClicked(MouseEvent e){
        if(!GameOver){
            int x = e.getX();
            int y = e.getY();
            
            //check if tower is clicked//
            for(Tower tower: towers){
                if(tower.contains(x, y)){
                    selectedTower = tower;
                    
                    //rotate towers if clicked//
                    selectedTower.rotate();
                    return;
                }
            }
            
            selectedTower = null;
            
            //check if user clikced location to create tower//
            for(Point loc: placementLocations){
                Rectangle towerRect = new Rectangle(loc.x-20, loc.y-20, 40, 40);
                if(towerRect.contains(x, y)){
                    //check if tower already exists there//
                    boolean towerExists = false;
                    for(Tower tower: towers){
                        if(tower.getX() == loc.x && tower.getY() == loc.y){
                            towerExists = true;
                            break;
                        }
                    }
                    
                    if(!towerExists){
                        //place tower if have enought money//
                        int basicTowerCost = 50;
                        if(money >= basicTowerCost){
                            towers.add(new BasicTower(loc.x, loc.y));
                            money -= basicTowerCost;
                        }
                    }
                    
                    return;
                }
            }
        }
    }
    
    
    
    //Main Game Loop//
    //@Override
    public void actionPerformed(ActionEvent e){
        if(!gameOver){
            //create spaceships//
            long currentTime = System.currentTimeMillis();
            if(currentTime-lastSpawnTime > spawnDelay && shipsSpawned < shipsToSpawn){
                spawnSpaceship();
                lastSpawnTime = currentTime;
                shipsSpawned++;
            }
            
            //start a new round if all spaceShips are spawned and destroyed (or escaped)//
            if(shipsSpawned >= shipsToSpawn && spaceships.isEmpty()){
                startNextRound();
            }
            
            //update game elements//
            updateSpaceships();
            updateTowers();
            
            repaint(); //refresh screen//
        }
    }
    
    
  
//    
//
// Mouse listener methods (required for interface) //
    @Override
    public void mouseClicked(MouseEvent e) {}
    @Override
    public void mousePressed(MouseEvent e) {}
    @Override
    public void mouseReleased(MouseEvent e) {}
    @Override
    public void mouseEntered(MouseEvent e) {}
    @Override
    public void mouseExited(MouseEvent e) {}
    // Override paintComponent to draw the game //
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        //draw words//
        g.setColor(Color.WHITE);
        g.drawString("Money: " + money + " | Health: " + health + " | Round: " + round, 10, 20);
        
        //draw tower cost//
        g2d.drawString("Tower Cost: 50", 10, 90);
        
        //draw elements//
        drawPath(g2d);      //draw path//
        for(Spaceship ship: spaceships){
            ship.draw(g2d);
        }
        drawPlacmentLocations(g2d);     //draw tower locations//
        for(Tower tower: towers){       //draw towers//
            tower.draw(g2d);
        }
        
        
    }
    //@Override
    public void actionPreformed(ActionEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }
    
    //make an entity//
    abstract class Entity{
        protected float x,y;
        protected int width, height;
        
        public Entity(float x, float y, int width, int height){
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        
        public float getX(){return x;}
        public float getY(){return y;}
        
        public boolean contains(int pointX, int pointY){
            return pointX >= x-width/2 && pointX <= x+width/2 && 
                    pointY >= y-height/2 && pointY <= y+height/2;
        }
        
        public abstract void draw(Graphics2D g);
    }
    
    //main spaceship class//
    abstract class Spaceship extends Entity{
        protected Point2D.Float[] path;
        protected int pathIndex = 0;
        protected float speed;
        protected int maxHealth;
        protected int health;
        protected int damage;
        protected int reward;
        
        //make constructor//
        public Spaceship(Point2D.Float[] path, int width, int height, int health, float speed, int damage, int reward){
            super(path[0].x, path[0].y, width, height);
            this.path = path;
            this.speed = speed;
            this.maxHealth = health;
            this.health = health;
            this.damage = damage;
            this.reward = reward;
        }
        
        //make the spaceships move//
        public void move(){
            if(pathIndex >= path.length -1) return;
            
            //calculate spaceships to move accordnig to path//
            float targetX = path[pathIndex+1].x;
            float targetY = path[pathIndex+1].y;
            
            float dx = targetX-x;
            float dy = targetY-y;
            float distance = (float)Math.sqrt(dx*dx + dy*dy);
            
            if(distance <= speed){
                pathIndex++;
                if(pathIndex<path.length-1){
                    move();
                }
            }else{
                x += dx/distance * speed;
                y += dy/distance * speed;
            }
        }
        
        //other aspects of ships taking damage//
        public void takeDamage(int damage){
            health -= damage;
        }
        public boolean hasReachedEnd(){
            return pathIndex >= path.length-1;
        }
        public int getDamage(){
            return damage;
        }
        public int getReward(){
            return reward;
        }
        
        //draw ship//
        public void draw(Graphics2D g){
            g.setColor(Color.GREEN);
            g.fillRect((int)(x-width/2), (int)(y-height/2), width, height);
            
            //draw health bar over ship//
            int healthBarWidth = width;
            int healthBarHeight = 5;
            g.setColor(Color.RED);
            g.fillRect((int)(x-healthBarWidth/2), (int)(y-height/2-10), healthBarWidth, healthBarHeight);
            g.setColor(Color.GREEN);
            g.fillRect((int)(x-healthBarWidth/2), (int)(y-health/2-10), 
                    (int)(healthBarWidth*(float)health/maxHealth), healthBarHeight);
        }
        
        protected abstract Color getColor();
    }
    
    class BasicSpaceship extends Spaceship{
        public BasicSpaceship(Point2D.Float[] path, int health, float speed){
            super(path, 30, 20, health, speed, 10, 20);
        }
       
       @Override
        protected Color getColor(){
            return new Color(255, 0, 0);
        }
    }
    
    
    
    
    //main tower class//
    abstract class Tower extends Entity{
        protected int cost, damage, range, fireRate, rotation = 0;
        protected long lastFireTime;
        protected Color color;
        protected boolean canTargetStealthed;
        
        public Tower(float x, float y, int width, int height, int cost, int damage, int range, int fireRate, Color color, boolean canTargetStealthed){
            super(x, y, width, height);
            this.cost = cost;
            this.damage = damage;
            this.range = range;
            this.fireRate = fireRate;
            this.lastFireTime = 0;
            this.color = color;
            this.canTargetStealthed = canTargetStealthed;
        }  
        
        public void update(){}
        
        public boolean canFire(){
            return System.currentTimeMillis()-lastFireTime > fireRate;
        }
        
        public void rotate(){
            rotation = (rotation + 90) % 360;
        }
        
        public int getRange(){
            return range;
        }
        
        public int getCost(){
            return cost;
        }
        
        public boolean canTargetStealthed(){
            return canTargetStealthed;
        }
        
        public abstract Projectile fire(Spaceship target);
        
        //helps tower find best target from a list of spaceships//
        public Spaceship findTarget(ArrayList<Spaceship> spaceships){
            Spaceship bestTarget = null;
            float closestDistance = range+1;
                
            for(Spaceship ship: spaceships){
                //skip stealth ships if tower can't target them//
                if(ship.isStealthed() && !canTargetStealthed){
                    continue;
                }
                
                float distance = (float) Math.sqrt(
                        Math.pow(ship.getX() - this.x, 2)
                        + Math.pow(ship.getY() - this.y, 2)
                );
                
                if(distance <= range && distance<closestDistance){
                    closestDistance = distance;
                    bestTarget = ship;
                }
            }
            
            return bestTarget;
        }
        
        @Override
        public void draw(Graphics2D g){
            drawTowerBase(g);
            drawTowerCannon(g);
            
            if(selectedTower == this){
                g.setColor(new Color(255, 255, 255, 50));
                g.fillOval((int) (x - range), (int) (y - range), range * 2, range * 2);
                g.setColor(new Color(255, 255, 255, 100));
                g.drawOval((int) (x - range), (int) (y - range), range * 2, range * 2);
            }
        }
        
        //customizing tower apperance//
        protected void drawTowerBase(Graphics2D g) {
            g.setColor(color);
            g.fillRect((int) (x - width / 2), (int) (y - height / 2), width, height);
        }

        protected void drawTowerCannon(Graphics2D g) {
            g.setColor(Color.GRAY);
            int cannonLength = width;
            int cannonWidth = width / 3;

            g.translate(x, y);
            g.rotate(Math.toRadians(rotation));
            g.fillRect(0, -cannonWidth / 2, cannonLength, cannonWidth);
            g.rotate(-Math.toRadians(rotation));
            g.translate(-x, -y);
        }
    }
}
